# -*- coding: utf-8 -*-
"""Sistem_Rekomendasi_Anime_Content_Based_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z4bA5SkkL_pyFcszWHlGdI1qi7E4FagJ

# Sistem Rekomendasi Anime dengan Content-Based Filtering

## 1. Business Understanding
Sistem rekomendasi anime ini dirancang untuk membantu pengguna menemukan anime baru berdasarkan preferensi konten dari anime yang mereka sukai sebelumnya. Pendekatan yang digunakan adalah **Content-Based Filtering**.

**Manfaat bisnis:**
- Meningkatkan engagement pengguna di platform anime
- Memperkenalkan anime baru yang sesuai minat
- Meningkatkan retensi pengguna

## 2. Import Libraries
Library berikut digunakan untuk pemrosesan data, visualisasi, dan pembuatan sistem rekomendasi.
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import save_npz
import joblib
import warnings
warnings.filterwarnings('ignore')

"""## 3. Data Loading
Memuat dataset `Top_Anime_data.csv` yang berisi informasi tentang anime populer tahun 2024.
"""

# Install & setup Kaggle
!pip install -q kaggle
from google.colab import files
files.upload()  # Upload kaggle.json
!mkdir -p ~/.kaggle && cp kaggle.json ~/.kaggle/ && chmod 600 ~/.kaggle/kaggle.json

# Download & extract dataset
!kaggle datasets download -d bhavyadhingra00020/top-anime-dataset-2024
import zipfile
with zipfile.ZipFile('top-anime-dataset-2024.zip', 'r') as z:
    z.extractall('.')

# Load data dengan fallback encoding
import pandas as pd
for enc in ['utf-8', 'ISO-8859-1', 'latin1']:
    try:
        anime_df = pd.read_csv('Top_Anime_data.csv', encoding=enc)
        break
    except:
        continue

# Tampilkan info dasar
print(f"\nShape: {anime_df.shape}")
print("\n5 data pertama:")
display(anime_df.head())

"""## 4. Data Understanding
Menampilkan informasi umum dan distribusi nilai pada dataset.
"""

# Info dataset
anime_df.info()

# Statistik deskriptif
anime_df.describe()

"""### Distribusi Skor Rating"""

plt.figure(figsize=(10,6))
sns.histplot(anime_df['Score'], bins=20, kde=True)
plt.title('Distribusi Rating Anime')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.show()

"""### Top 10 Anime Berdasarkan Rating"""

top_anime = anime_df.sort_values('Score', ascending=False).head(10)
plt.figure(figsize=(10,6))
sns.barplot(x='Score', y='English', data=top_anime)
plt.title('Top 10 Anime Berdasarkan Rating')
plt.xlabel('Rating')
plt.ylabel('Judul Anime')
plt.show()

"""## 5. Data Preparation
### Handling Missing Values
"""

# Isi missing values
anime_df['Description'] = anime_df['Description'].fillna('')
anime_df['Genres'] = anime_df['Genres'].fillna('Unknown')
anime_df['Type'] = anime_df['Type'].fillna('Unknown')

"""### Feature Engineering
Menggabungkan fitur konten menjadi satu kolom.
"""

anime_df['content_features'] = anime_df['Genres'] + ' ' + anime_df['Type'] + ' ' + anime_df['Description']
anime_df['content_features'] = anime_df['content_features'].str.lower()

"""## 6. Modeling dengan TF-IDF dan Cosine Similarity"""

# TF-IDF Vectorization
tfidf = TfidfVectorizer(stop_words='english', ngram_range=(1, 2), max_features=5000)
tfidf_matrix = tfidf.fit_transform(anime_df['content_features'])

print("Shape TF-IDF Matrix:", tfidf_matrix.shape)

# Cosine Similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix, dense_output=False)
save_npz('cosine_sim_matrix.npz', cosine_sim)
print("Shape Similarity Matrix:", cosine_sim.shape)

"""## 7. Fungsi Rekomendasi Anime"""

def get_enhanced_recommendations(title, cosine_sim=cosine_sim, df=anime_df, top_n=10):
    try:
        idx = df[df['English'] == title].index[0]
        sim_scores = list(enumerate(cosine_sim[idx].toarray().flatten()))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
        anime_indices = [i[0] for i in sim_scores]
        similarity_values = [i[1] for i in sim_scores]
        recommendations = df[['English', 'Genres', 'Score', 'Type', 'Episodes', 'Studios']].iloc[anime_indices]
        recommendations['Similarity'] = similarity_values
        return recommendations
    except IndexError:
        print(f"Anime dengan judul '{title}' tidak ditemukan.")
        return None

"""## 8. Contoh Penggunaan Rekomendasi"""

print("=== Rekomendasi untuk 'Attack on Titan Season 3 Part 2' ===")
get_enhanced_recommendations("Attack on Titan Season 3 Part 2")

"""## 9. Evaluasi Model dengan Precision@K"""

def precision_at_k(actual_title, recommended_titles, k=10, genre_threshold=0.6):
    try:
        target_genres = set(anime_df.loc[anime_df['English'] == actual_title, 'Genres'].iloc[0].split(', '))
        matches = 0
        for title in recommended_titles['English'].head(k):
            rec_genres = set(anime_df.loc[anime_df['English'] == title, 'Genres'].iloc[0].split(', '))
            if len(target_genres) > 0 and len(rec_genres) > 0:
                overlap = len(target_genres.intersection(rec_genres)) / len(target_genres)
                if overlap >= genre_threshold:
                    matches += 1
        return matches / k
    except:
        return 0

test_cases = ["Attack on Titan Season 3 Part 2", "Fullmetal Alchemist: Brotherhood"]
results = []

for anime in test_cases:
    recs = get_enhanced_recommendations(anime, top_n=10)
    if recs is not None:
        prec = precision_at_k(anime, recs)
        results.append(prec)
        print(f"Precision@10 untuk {anime}: {prec:.2f}")

print(f"Rata-rata Precision@10: {np.mean(results):.2f}")

"""## 10. Penyimpanan Model"""

joblib.dump({
    'tfidf_vectorizer': tfidf,
    'cosine_sim_matrix': cosine_sim,
    'anime_data': anime_df
}, 'anime_recommender_system.pkl')
print("Model berhasil disimpan.")

"""## 11. Kesimpulan
Sistem rekomendasi berbasis konten telah berhasil dibangun menggunakan fitur `Genres`, `Type`, dan `Description`. Evaluasi menggunakan Precision@10 menunjukkan bahwa sistem memberikan rekomendasi yang relevan berdasarkan kesamaan konten.

Untuk pengembangan ke depan, sistem dapat ditingkatkan dengan:
- Menambahkan pendekatan collaborative filtering
- Mempertimbangkan preferensi pengguna eksplisit
"""